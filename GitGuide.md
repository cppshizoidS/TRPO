
# Гайд по Git для начинающих

## Введение

[Git](https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control) - это распределенная система управления версиями, которая позволяет отслеживать изменения в коде и вести совместную разработку.
### Основные понятия:
-   Репозиторий(Repository) - место, хранится ваш проект и все его коммиты
-   Коммит(Commit) - запись изменений(снимков файлов) в проекте. У каждого коммита есть свой уникальный идентификатор
-   Ветка(Branch) - это подвижный указатель на один из коммитов. Обычно ветка указывает на последний коммит в цепочке коммитов. Ветка берет свое начало от какого-то одного коммита. Коммиты в разных ветках не влияют на коммиты в другой и поэтому если вы закоммитили в ветку с названием lab1 этот коммит не будет отображаться в ветке master

### Установка и настройка Git на Debian/Ubuntu/Fedora

1.  Откройте терминал
2.  Установите git командой: ```sudo apt install git```/```sudo dnf install git```
3.  После установки проверьте версию git чтобы убедиться что гит установлен: командой ```git --version```
4.  Основные настройки: 
    ```git config --global user.name "Ваше Имя"```
    ```git config --global user.email "ваша@почта.com"```
5. Изменение редактора для редактирования(по дефолту nano(например для --amend)):
   ```git config --global core.editor "название редактора(vim/nvim/vscode)"```
    Установить nvim как основной редактор:
    ```git config --global core.editor "nvim"```
    Установить vscode как основной редактор:
    ```git config --global core.editor "code --wait"```
Это необходимо если перменные окружения "EDITOR" не выставлены

### Прокидывание ключей

* Шаг 1. Генерация ssh ключа

Откройте терминал (или командную строку) на вашем компьютере.
Введите следующую команду, чтобы начать процесс генерации SSH-ключа. Замените <ваш_email> на свой email от гитлаба.

```sh
ssh-keygen  -t  rsa  -b  4096  -C  "<ваш_email>"
Процесс  генерации  запросит  вас  ввести  место  для  сохранения  ключа.  Нажмите  Enter,  чтобы  использовать  место  по  умолчанию (обычно ~/.ssh/id_rsa).
```
Введите email от гитлаба ip314sNN@csc.sibsutis.ru NN-номер в вашем гитлабе

Ключ будет сгенерирован. Вы увидите сообщение о том, что ключ успешно создан.



* Шаг 2. Добавление SSH-ключа на GitLab

Сначала скопируйте ваш открытый ключ, который обычно находится в файле `~/.ssh/id_rsa.pub.` Вы можете использовать команду `cat` или открыть файл в текстовом редакторе.

```sh
cat  ~/.ssh/id_rsa.pub
```
Копируйте вывод ключа
  
- Зайдите в свой аккаунт на GitLab.
- В правом верхнем углу страницы, нажмите на свой аватар и выберите "Settings".
- В меню слева выберите "SSH Keys".
- Вставьте скопированный ранее открытый ключ в поле "Key".
- Дайте ключу описательное имя, чтобы вы могли легко определить его (например, "Мой компьютер").

Нажмите "Add key", чтобы сохранить ключ.

Если все настроено правильно, вы увидите сообщение подтверждения.

### Работа с коммитами
-   Перейдите в папку где нужно создать репозиторий
-   Создать репозиторий ```git init```
-   Посмотреть изменения в проекте(!!!! локально): ```git status```
-   Добавить файлы для коммита: ```git add файл.txt```(реальное имя файла и его расширение например для си в лабе: ```git add main.c```)
-   Посмотреть изменения в файле: ```git diff``` (git diff отображает изменения между вашим рабочим каталогом и последним коммитом)

Например вы добавили функцию main() при вводе команды ```git diff``` вы увидете    что-то подобное:

![](https://lh7-us.googleusercontent.com/xCB6-6jnX-YBgYQ2QKlcH6mhpWsfDsmXb_4RJlJnwMoYVlXwacTduvOH9TvA__YTKYtDgqjXV4U1GLmqYnqzVhNwqX3EkC06Ol9GEMjgmTKU2MUQRQTaMNAjhO-pg9HAKDkC2rHKMTmqYB3b2WjUhHw)

-   Если использовать ```git diff --staged``` вы увидите что уже проиндексированои что попадет в коммит

-   Сделать коммит: ```git commit <название файла(в нашей лабе файл называется main.c>-m "тут пишется сообщение описывающее коммит например: добавил функцию aboba()"```


-   Посмотреть истории изменений(коммитов):  ```git log```
![](https://lh7-us.googleusercontent.com/ysHjHOdZYS-Kl58aQ2A9HWnJyzvxffO9X2ke20saRQT18Vg550D_s1Pyb99v4udqC2xBu3JjrHPAyhNIAL79IFMfaa5XsSPo0ifFuSW5nIrYLXr70X2LpIbYRAMbWP_fTVji1QAX-SK9VRVhiQ_OlxQ)

### Флаги для ```git log ```
- ``` git log --graph ``` - отображает граф с ветвлениями и историей мержа

- ``` git log --online ``` - печатает каждый коммит в одну строку

- ``` git log --since/--until ``` - ограничение вывод по времени 

- ``` git log -p ``` - показывает патч каждого коммита

- ``` git log --stat ``` - показывает статистику об измененных файлах


- 	Чтобы откатить изменения без их сохранения ```git reset--hard HEAD~1``` 

- 	Чтобы внести изменения в последний коммит ``` git commit --amend```

- 	Чтобы добавить в коммит забытый файл 
```git commit -m "Do something"```
```git add <forgotten_file>```
```git commit --amend ```

- Чтобы измениь заголовок последнего коммита    
``` git commit -m "Delete unused func" ```
``` git commit --amend -m "Delete unsed function in header file" ```

-   Добавить удаленную репу: ```git remote origin URL_репы```

-   Запушить(загрузить) изменения на удаленную репу:

```git push --set-upstream origin lab1``` (git push комманда для загруки --set-upstream origin <branch-name>) например branch-name в нашей лабе название ветки это 
Или же ```git push -u origin lab``` (-u тоже самое что --set-upstream)

-   Скачать изменения с удаленного репозитория ```git pull origin <ветка>``` в лабе вместо <ветка> будет lab1
### Ветвление

-   Создать ветку: ```git branch <название ветки>```

-   Переключение на ветку: ```git checkout  <название ветки>```

-   Чтобы создать ветку и сразу переключиться на нее: ```git checkout -b <название ветки>```

Допустим у вас есть ветка master вам нужно создать ветку с фиксом hotfix

- ``` git checkout -b hotfix ```

Производите изменения
 -``` git commit -a -m 'added hotfix' ```

Переключаетесь на master
- ``` git checkout master```

Проводите слияние веток
- ``` git merge hotfix ```

Удаление ветки после хотфикса
- ``` git branch -d hotfix ```

#### Управление ветками
- ``` git branch ``` - вывод списка всех веток

- ``` git branch --merged ``` - вывод влитых веток

- ``` git branch --no-merged ``` - вывод еще не влитых веток

- ``` git branch --move old-branch-name new-branch-name ``` - переименование веток(локально)

- ``` git push --set-upstream origin new-branch-name ``` - пуш переименования ветки

- ``` git push origin --delete old-branch-name ``` - удаление старой ветки со старым названием

- ``` git branch --all ``` - вывод всех веток

- ```git branch -D branch-name``` - принудительное удаление старой вети со старым названием 

### Merge and Rebase

Когда вы используете `git merge`, Git создает новый коммит слияния, который объединяет изменения из двух веток.
Этот коммит имеет двух родителей - по одному от каждой ветки, которая была слита.
История каждой ветки сохраняется и остается наглядной и читаемой.
Каждая ветка сохраняет свою собственную историю разработки.
Как результат, история может стать более сложной и нелинейной, особенно при интенсивном использовании веток.

При использовании `git rebase`, Git берет коммиты из текущей ветки и применяет их поверх целевой ветки. Создаются новые коммиты, история становится линейной.
Этот подход позволяет создавать более чистую и линейную историю изменений, что может быть полезным для поддержания читаемости истории проекта.
При переписывании истории коммиты получают новые идентификаторы, что может вызвать проблемы при работе в тиме, если кто-то уже использовал старые идентификаторы.

### Переключаемся на целевую ветку, например, master
- ``` git checkout master ``` -  переключаемся на master

- ``` git rebase feature-branch ``` - применяем коммиты из master на feacture-branch

- ``` git rebase --continue ``` - продолжит ребейз не смотря на конфлиты

- ``` git checkout feature-branch ``` - переключаемся на ветку с фичей которую ребейзим

- ``` git rebase new-base-branch ``` -  завершаем ребейз на новой ветке

### Конфликты merge

Конфликты мержа в Git возникают, когда две ветки изменяют одни и те же строки в одном и том же файле, и Git не может автоматически определить, какие изменения применить. Разрешение конфликтов — важная часть работы с системой контроля версий. Вот шаги для выполнения слияния веток с последующим разрешением конфликтов.

* Шаг 1: Обновление веток
Перед тем, как начать мержить, удостоверьтесь, что ваш репозиторий обновлен. Для этого выполните команды:

```bash
git checkout ваша_целевая_ветка
git pull origin ваша_целевая_ветка
git checkout ваша_исходная_ветка
git pull origin ваша_исходная_ветка
```

* Шаг 2: Выполнение мержа
Теперь выполните мерж ветки, которую вы хотите влить в другую:

```bash
git checkout ваша_целевая_ветка
git merge ваша_исходная_ветка
```
Если конфликты не возникли, Git автоматически выполнит мерж, и вы можете перейти к следующему шагу. В противном случае, Git сообщит о конфликтах и остановится.

* Шаг 3: Разрешение конфликтов
Откройте конфликтные файлы в вашем редакторе кода. Вы увидите метки <<<<<<<, =======, и >>>>>>>, между которыми будут указаны изменения из обеих веток.

Пример конфликта в файле:
```shell
<<<<<<< HEAD
Код с целевой ветки
=======
Код с исходной ветки
>>>>>>> ваша_исходная_ветка
```
Вам нужно выбрать, какие изменения оставить. Удалите метки конфликта и внесите необходимые правки. Сохраните файл.

* Шаг 4: Пометка файлов как разрешенных
После того как вы разрешили все конфликты в файлах, добавьте их в индекс с помощью:

```bash
git add путь_к_файлу
```
* Шаг 5: Завершение мержа
Теперь можно завершить мерж:

```bash
git merge --continue
```
или

```bash
git merge --continue --no-edit
```
Это завершит мерж, используя автоматическое сообщение коммита, иначе Git запросит вас ввести сообщение для коммита.

* Шаг 6: Проверка результата
После успешного завершения мержа, вы можете выполнить ```git log``` или ```git show``` для просмотра истории коммитов и убедиться, что все изменения были влиты корректно.

Теперь у вас должен быть разрешенный мерж с вашими изменениями.

## gitignore 

```.gitignore``` - это файл в Git, который содержит список файлов, расширений или папок, которые вы хотите исключить из отслеживания системы контроля версий. Использование .gitignore помогает избежать добавления лишних файлов в репозиторий, таких как временные файлы, скомпилированные бинарные файлы, файлы настроек и т. д.

Зачем нужен ```.gitignore```
-   Исключение бинарных файлов: Компилированные файлы например a.out
-   Кэш файлов сборки/генераторов файлов сборки например при использовании cmake создаются папки: CMakeFIles  .cmake и файлы CMakeCache.txt cmake_install.cmake, у билд системы ninja создаются файлы .ninja_deps .ninja_log
-   Скомпилированные динамические библиотеки: .dll(на windows) .so (на linux)
-   Скомпилированные статические библиотеки: .a(linux) .lib(windows)

Пример ```.gitignore``` для C и C++:
```gitignore
#Пререквизиты:
*.d

#Скомпилированные объектные файлы:
*.slo
*.lo
*.o
*.obj

#Предварительно скомпилированные заголовки
*.gch
*.pch

#Скомпилированные динамические библиотеки
*.so
*.dylib
*.dll

#Файлы резервных копий редактора
*~
.*.swp

#Скомпилированные статические библиотеки
*.lai
*.la
*.a
*.lib
#Исполняемые файлы
*.exe
*.out
*.app

#файлы сборки(для лаб они не нужны но будут полезны если решите изучать плюсы и тулинг для них дальше)
.ninja_*
CMakeFiles/*
Testing/*
.cmake/*
CMakeCache.txt
build_ninja
cmake_install.cmake
```

Полезные ресурсы по git:
```
https://learngitbranching.js.org/
https://git-scm.com/book/en/v2
https://git-scm.com/videos
```
