# Экзамен

## 1. Тестирование ПО: методы белого и чёрного ящика

Тестирование — важный этап разработки нового продукта. В процессе тестирования можно выявить ошибки в работе программы и вовремя их исправить.

Тестирование происходит на трех уровнях:
- **Unit-тесты** (проверка корректности работы отдельных модулей программного кода).
- **Интеграционные тесты** (проверка взаимодействия различных компонентов программы).
- **End-to-end тесты** (когда задействована вся система: это может быть ручное тестирование или автоматизированные тесты).

### Метод белого ящика

White box testing основывается на анализе внутренней структуры программы. Тестировщик знает, как работает программа и какие функции выполняет каждый ее блок. Основной фокус в этом методе — на коде. Он исследует структуру каталогов, маршрутизацию, циклы и при необходимости может самостоятельно изменить код.

### Метод чёрного ящика

Black box testing — проверка, при которой тестировщик не имеет доступа к коду. Он, как реальный клиент или пользователь, оценивает функции и работу программы, ориентируясь исключительно на интерфейс взаимодействия. Может быть применен без доступа к исходному коду.

## 2. Система контроля версий: история развития (RCS, CVS, SVN и git), локальные, централизованные и распределённые системы.

### RCS (Revision Control System)

- Написана в 1982 году Уолтером Тихи на языке С в качестве альтернативы системе SCCS (Source Code Control System), которая в то время не была опенсорсной.

### CVS (Concurrent Versions System)

- CVS создана Диком Груном в 1986 году с целью добавить в систему управления версиями поддержку сети. Она также написана на C. Благодаря ей географически рассредоточенные команды разработчиков получили возможность работать над проектами вместе.

### SVN (Subversion)

- Subversion создана в 2000 году компанией Collabnet Inc., а в настоящее время поддерживается Apache Software Foundation. Система написана на C и разработана как более надёжное централизованное решение, чем CVS.

### Git

- Систему Git разработал в 2005 году Линус Торвальдс. Она написана в основном на C в сочетании с некоторыми сценариями командной строки. Отличается от VCS по функциям, гибкости и скорости. Торвальдс изначально написал систему для кодовой базы Linux, но со временем её сфера использования расширилась, и сегодня это самая популярная в мире система управления версиями.

### Системы контроля версий

Системы контроля версий бывают локальными, централизованными или распределёнными:
- **Локальная система** хранит файлы на одном устройстве.
- **Централизованная система** использует общий сервер.
- **Распределённая система** использует общее облачное хранилище и локальные устройства участников команды.

В локальной системе удобно работать с большими проектами, но сложно взаимодействовать с удалённой командой. В централизованной системе налажена удалённая работа, но всё привязано к одному серверу. Любой сбой или взлом может повредить файлы проекта. В распределённой системе налажена удалённая работа. Если с файлами основного репозитория что-то случится — проект легко восстановить из копии любого участника команды.

## 3. Git на локальной машине: локальный проект и удаленный репозиторий

### Схема взаимодействия

- **Локальный репозиторий** - проект на вашем компьютере.
- **Удалённый репозиторий** - копия вашего проекта на сервере (например, GitHub, GitLab и т.д.).
- **Ветки (branches)** - отдельные линии разработки.
- **Коммиты (commits)** - зафиксированные изменения в репозитории.

### Основные команды Git

#### Создание нового репозитория

### Создание нового локального репозитория:
```sh
git init
``` 

### Клонирование удаленного репозитория
Для начала работы с существующим проектом из удаленного репозитория:
```sh
 git clone <URL удалённого репозитория>
 ```

### Статус репозитория
Просмотр текущего состояния репозитория:
```sh
git status
```

### Добавление файлов в индекс (стадия подготовки)
Для добавления изменений в индекс:
```sh 
git add <файл/папка>
```
 или для добавления всех изменений:
```sh
git add .
```

### Создание коммита
Зафиксировать изменения в локальном репозитории:
```sh
git commit -m "Сообщение коммита"
```

### Подключение удалённого репозитория
Для добавления удалённого репозитория:
```sh
git remote add origin <URL удалённого репозитория>
```

### Отправка изменений в удалённый репозиторий
Для отправки изменений в основную ветку удалённого репозитория:
```sh
git push origin master
```

### Обновление локального репозитория
Для получения изменений из удалённого репозитория:
```sh
git pull origin master
```

# Работа с ветками
### Создание новой ветки:
```sh
git branch <имя_ветки>
```
### Переключение на другую ветку:
```sh
git checkout <имя_ветки>
```

### Создание и переключение на новую ветку:
```sh
git checkout -b <имя_ветки>
```

## Слияние веток
Слияние изменений из другой ветки в текущую:
```sh
git merge <имя_ветки>
```

### Удаление ветки
Удаление локальной ветки:
```sh 
git branch -d <имя_ветки> 
```

Удаление удалённой ветки:
```sh
git push origin --delete <имя_ветки>
```



## 4. Git:Создание репозитория + фиксация изменений, стадии процесса
Если у вас уже есть проект в каталоге, который не находится под версионным контролем Git, то для начала нужно перейти в него. Если вы не делали этого раньше, то для разных операционных систем это выглядит по-разному:
для Linux:

``` $ cd /home/user/my_project ```

а затем выполните команду:

``` $ git init```

Если вы хотите добавить под версионный контроль существующие файлы (в отличие от пустого каталога), вам стоит добавить их в индекс и осуществить первый коммит изменений. Добиться этого вы сможете запустив команду git add несколько раз, указав индексируемые файлы, а затем выполнив git commit:
```sh 
$ git add *.c
$ git add LICENSE
$ git commit -m 'Initial project version'
```


## 5. Git: откат изменений, добавление изменений в последний коммит
Отмена может потребоваться, если вы сделали коммит слишком рано, например, забыв добавить какие-то файлы или комментарий к коммиту. Если вы хотите переделать коммит — внесите необходимые изменения, добавьте их в индекс и сделайте коммит ещё раз, указав параметр `--amend`:
```sh
$ git commit --amend
```
Эта команда использует область подготовки (индекс) для внесения правок в коммит. Если вы ничего не меняли с момента последнего коммита (например, команда запущена сразу после предыдущего коммита), то снимок состояния останется в точности таким же, а всё что вы сможете изменить — это ваше сообщение к коммиту.

Что делать, если вы поняли, что не хотите сохранять свои изменения файла, Как можно просто отменить изменения в нём — вернуть к тому состоянию, которое было в последнем коммите (или к начальному после клонирования, или ещё как-то полученному)?  `git status` подсказывает и это тоже.

В выводе команды из последнего примера список изменений выглядит примерно так:
```sh
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
    modified:   CONTRIBUTING.md
```
Здесь явно сказано как отменить существующие изменения. Давайте так и сделаем:
```sh
$ git checkout -- CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)


   renamed:    README.md -> README
```

## 6. Git: создание ветки 
``` $ git branch iss53```

``` $ git checkout iss53```

или ``` $ git checkout -b iss53```


## 7. Git: объединение веток
```git merge <branch for merge> <source branch(main)> ```

`no-ff` - no fast forward мерж с коммитом слияния

`ff` - fast forward мерж без коммита слияния 


## 8. Git:конфликты и способы решения
Git конфликты возникают, когда изменения вносятся в один и тот же участок кода несколькими разработчиками одновременно. 
Эти конфликты требуют ручного вмешательства для их разрешения. 
После выполнения команды `git pull` или `git merge`, если возникает конфликт, Git уведомит вас об этом и покажет, в каких файлах они произошли.
### Просмотр конфликтных файлов
Откройте конфликтные файлы в вашем текстовом редакторе или IDE. Git отметит конфликтные участки специальными метками:
```
<<<<<<< HEAD
ваш код
=======
чей то код
>>>>>>> имя_ветки
````

## Ручное разрешение конфликта

Отредактируйте конфликтные участки, выбрав нужные изменения или объединив оба варианта кода.

Удалите все метки конфликтов (`<<<<<<<`, `=======`, `>>>>>>>`).

### Добавление разрешенных файлов
После разрешения всех конфликтов добавьте файлы в индекс с помощью команды:

`git add <имя_файла>`

### Завершение merge  или pull
После добавления всех файлов завершите слияние или извлечение командой:
`git commit`

Если вы использовали `git merge`, завершите слияние с `git commit`.


Если вы использовали `git rebase`, продолжите rebase с помощью:
`git rebase --continue`


### Просмотр конфликтов в реальном времени:
`git status`
Эта команда покажет, какие файлы находятся в конфликте.


## 9. Git:работа с удаленным репозиторием 
Работа с удаленными репозиторием git fetch и git pull 
Работа с удаленными репозиториями в Git включает команды `git fetch` и `git pull`, которые используются для получения изменений из удаленного репозитория. 

### git fetch
Команда `git fetch` загружает все изменения из удаленного репозитория, но не объединяет их с вашей текущей веткой. Она обновляет локальные копии удаленных веток.
Пример:

```git fetch origin```

Эта команда загружает все изменения из удаленного репозитория `origin`.

### git pull

Команда `git pull` сочетает в себе две команды: `git fetch` и `git merge`. Она сначала загружает изменения из удаленного репозитория, а затем пытается объединить эти изменения с вашей текущей веткой.
Пример:

``` git pull origin main```

Эта команда загружает изменения из удаленного репозитория `origin` и объединяет их с локальной веткой `main`.

#### Основные различия:
- `git fetch`:
  - Получает изменения из удаленного репозитория.
  - Не изменяет ваш рабочий каталог.
  - Позволяет просмотреть изменения перед их объединением.
- `git pull`:
  - Получает и объединяет изменения из удаленного репозитория.
  - Автоматически обновляет ваш рабочий каталог.
  - Может привести к конфликтам слияния, если есть несогласованные изменения.

#### Когда использовать
- Используйте `git fetch`, когда хотите просмотреть изменения перед их объединением в вашу ветку. Это полезно, если вы хотите оценить, какие изменения были сделаны, и как они могут повлиять на ваш код.
- Используйте `git pull`, когда вы уверены, что хотите сразу объединить изменения из удаленного репозитория в вашу текущую ветку.


## 10. Работа с удаленными репозиторием `git rebase`
 Использование git rebase с удалёнными репозиториями

- Обновление локальной ветки на основе удаленной
Если вам нужно обновить вашу локальную ветку на основе удалённой, вы можете использовать rebase вместо merge для сохранения линейной истории.

  * `git fetch origin`

  * `git rebase origin/main`

  Эта команда сначала загружает изменения из удалённого репозитория, а затем перемещает ваши локальные коммиты на вершину origin/main.


- Изменение истории в удалённом репозитории
После использования rebase необходимо принудительно отправить изменения в удалённый репозиторий, поскольку история коммитов была изменена.


Пример:
```sh
git rebase origin/main
git push origin main --force
```
*: Использование `--force` может переписать историю в удалённом репозитории, что может привести к проблемам для других разработчиков, работающих с этой веткой.


### Преимущества `git rebase`:

* Чистая история: История коммитов остаётся линейной и более понятной.
* Избегание лишних слияний: Избегает создания лишних коммитов слияния, которые могут засорять историю.
### Недостатки git rebase:
* Риск потери данных: При неправильном использовании, особенно с `--force`, можно потерять коммиты.
* Проблемы для команды: Если кто-то уже начал работать с веткой, которую вы переписали, это может вызвать конфликты и недоразумения.


## 11. Работа с удаленными репозиторием `git push`

Команда `git push` используется для отправки ваших локальных изменений в удаленный репозиторий.
Она синхронизирует ваши изменения с удалённой веткой, позволяя другим разработчикам видеть и использовать ваши коммиты. 

### Отправка изменений в удалённый репозиторий:
``` git push origin main```

Эта команда отправляет все ваши локальные коммиты из ветки main в удалённый репозиторий origin.

### Отправка новой ветки:
``` git push origin new-branch```

Эта команда создаёт новую ветку new-branch в удалённом репозитории и отправляет туда ваши локальные коммиты.


### Принудительная отправка (force push)
Если вы изменили историю коммитов (например, с помощью git rebase), вам может понадобиться принудительно отправить изменения в удалённый репозиторий:
``` git push origin main --force``` [^1]

[^1]: Использование `--force` может перезаписать историю в удалённом репозитории, что может привести к проблемам для других разработчиков, работающих с этой веткой.


### Безопасная принудительная отправка (force-with-lease)
Для более безопасного принудительного отправления изменений можно использовать опцию `--force-with-lease`. 

Эта опция проверяет, что удалённая ветка не была изменена с момента последнего её получения:

``` git push origin main --force-with-lease```

### Удаление ветки в удалённом репозитории
Чтобы удалить ветку в удалённом репозитории, используйте следующую команду:

``` git push origin --delete branch-name ```

### Отправка всех веток
Для отправки всех локальных веток в удалённый репозиторий можно использовать опцию `--all`:

``` git push origin --all```

Чтобы установить ветку по умолчанию для git push, можно использовать команду `--set-upstream`:

``` git push --set-upstream origin new-branch```

## 12. git модель ветвления
- `master` ветка должна всегда быть готова к развертыванию.
- Все изменения вносятся через feature-ветки (pull-request + merge).
- Используется rebase для избежания/разрешения конфликтов; merge в master.

### Рабочий процесс:
1. Все начинается с актуальной и работоспособной master ветки.
2. Для внесения изменений создается новая `feature-ветка`:

   - `git checkout -b my-new-feature`
   - Вносятся изменения, делаются коммиты

3. Для синхронизации с изменениями в master и других feature-ветках используется rebase:
   - `git fetch origin`
   - `git rebase origin/my-new-feature`
   - `git rebase origin/master`

4. Опционально: `feature-ветка` может быть отправлена на GitHub для обсуждения (pull-request).
5. Когда feature-разработка завершена, ветка сливается в `master`:
   - `git checkout master`
   - `git pull origin master`
   - `git merge --no-ff my-new-feature`


#### Рекомендации:
- Держать `master` в рабочем состоянии
- Использовать `rebase` для `feature-веток`
- Не вносить изменения напрямую в `master`
- Не делать `hotfix-ы` в `master`, использовать `feature-ветку`
- Использовать теги для важных вещей, таких как релизы


## 13. Системы автоматизации сборки: цели, задачи, примеры

 Цели и задачи систем автоматизации сборки: 
###  Цели: 
  - Ускорение и упрощение процесса сборки программного обеспечения.
  - Обеспечение повторяемости и надежности сборки.
  - Уменьшение количества ошибок, связанных с ручной сборкой.

###  Задачи: 
  - Автоматизация процессов компиляции, тестирования и упаковки приложения.
  - Управление зависимостями и версиями библиотек.
  - Интеграция с системами контроля версий и системами непрерывной интеграции (CI).

 ### Примеры систем автоматизации сборки: 
-  Apache Ant:  популярная система сборки для проектов на языке Java, основанная на XML-скриптах.
-  Maven:  инструмент управления проектами и сборки для Java, использующий декларативные скрипты и ориентированный на управление зависимостями.
-  Gradle:  гибкая система сборки, поддерживающая множество языков программирования и платформ, использующая DSL на основе Groovy или Kotlin.
-  Make:  классическая система сборки, часто используемая для проектов на C/C++, основанная на Makefile.

## 14. Системы автоматизации сборки: переменные пользовательские и автоматические

 Переменные пользовательские и автоматические: 
-  Пользовательские переменные:  задаются пользователем и могут быть использованы для конфигурации процесса сборки. Например, в Gradle можно определить переменные в файле build.gradle:
  ```groovy
  ext {
      myVariable = 'value'
  }
  ```

-  Автоматические переменные:  создаются системой сборки и содержат информацию, необходимую для выполнения сборки. В Makefile, например, существуют специальные автоматические переменные, такие как `$@` (имя цели), `$<` (имя первого зависимого файла), `$^` (список всех зависимых файлов).

## 15. Непрерывная интеграция: цели, основные принципы, инструментарий

Цели непрерывной интеграции (CI):
- Обеспечение постоянного интегрирования кода разработчиков в общий репозиторий.
- Выявление и исправление ошибок на ранних стадиях разработки.
- Поддержка стабильности и качества кода.

 Основные принципы непрерывной интеграции: 
-  Частые коммиты:  разработчики часто интегрируют изменения в основной репозиторий.
-  Автоматическое тестирование:  каждый коммит запускает автоматические тесты, которые проверяют работоспособность кода.
-  Единый сборочный процесс:  автоматизация процесса сборки и тестирования для всех изменений кода.
-  Быстрая обратная связь:  разработчики получают оперативную информацию о состоянии системы после каждого коммита.

 Инструментарий для непрерывной интеграции: 
-  Jenkins:  мощная и гибкая система CI/CD с поддержкой множества плагинов.
-  Travis CI:  облачный сервис CI, интегрирующийся с GitHub, поддерживающий множество языков и платформ.
-  CircleCI:  облачная платформа для CI/CD, поддерживающая контейнерные и виртуализированные окружения.
-  GitLab CI/CD:  встроенные функции CI/CD в систему управления репозиториями GitLab, обеспечивающие полную интеграцию с процессом разработки.

Эти системы и инструменты помогают разработчикам поддерживать высокий уровень качества кода и эффективно управлять процессом разработки программного обеспечения.
